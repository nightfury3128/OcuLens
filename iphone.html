<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>iPhone Webcam Streamer</title>
  <style>
    body { text-align: center; font-family: sans-serif; }
    video { width: 90vw; max-width: 480px; border: 2px solid #333; border-radius: 8px; }
    button { margin-top: 16px; padding: 10px 20px; font-size: 1.2em; }
    select { margin: 5px; padding: 5px; }
  </style>
</head>
<body>
  <h2>iPhone Webcam Streamer</h2>
  <video id="video" autoplay playsinline></video><br>
  <label for="camera">Camera:</label>
  <select id="camera">
    <option value="">Loading cameras...</option>
  </select>
  <br>
  <label for="resolution">Resolution:</label>
  <select id="resolution">
    <option value="3840x2160">3840x2160 (4K)</option>
    <option value="1280x720">1280x720</option>
    <option value="960x540">960x540</option>
    <option value="640x360">640x360</option>
  </select>
  <br>
  <label for="quality">Quality:</label>
  <select id="quality">
    <option value="high">High (0.8)</option>
    <option value="medium" selected>Medium (0.7)</option>
    <option value="low">Low (0.5)</option>
    <option value="auto">Auto (Adaptive)</option>
  </select>
  <br>
  <label for="maxFps">Max FPS:</label>
  <select id="maxFps">
    <option value="60">60 FPS</option>
    <option value="30" selected>30 FPS</option>
    <option value="24">24 FPS</option>
    <option value="15">15 FPS</option>
    <option value="10">10 FPS</option>
  </select>
  <button id="start">Start Streaming</button>
  <p id="status"></p>
  <p id="fpsDisplay"></p>
  <p id="performanceInfo" style="font-size: 0.9em; color: #666;"></p>
  <script>
    const video = document.getElementById('video');
    const startBtn = document.getElementById('start');
    const status = document.getElementById('status');
    const resolutionSelect = document.getElementById('resolution');
    const cameraSelect = document.getElementById('camera');
    const fpsDisplay = document.getElementById('fpsDisplay');
    const qualitySelect = document.getElementById('quality');
    const maxFpsSelect = document.getElementById('maxFps');
    const performanceInfo = document.getElementById('performanceInfo');
    let streaming = false;
    let cameraStarted = false;
    let uploading = false;
    let lastFrameTime = 0;
    let frameCount = 0;
    let fpsTimer = null;    let currentWidth = 1280;
    let currentHeight = 720;
    let useWebP = false;
    let wakeLock = null;
    let reconnectTimer = null;
    let streamReconnectAttempts = 0;
    const MAX_RECONNECT_ATTEMPTS = 5;
    
    // Network efficiency variables
    let adaptiveQuality = 0.7;
    let targetFPS = 60;  // Default to 60 FPS
    let currentFPS = 60;
    let networkLatency = 0;
    let frameDropCount = 0;
    let lastSuccessTime = Date.now();
    let frameSkipCounter = 0;
    let compressionLevel = 0.7;
    let dynamicResolution = false;

    // Function to keep screen awake
    async function requestWakeLock() {
        try {
            if ('wakeLock' in navigator) {
                wakeLock = await navigator.wakeLock.request('screen');
                console.log('Wake Lock is active');
                wakeLock.addEventListener('release', () => {
                    console.log('Wake Lock was released');
                    if (streaming) {
                        // Try to reacquire wake lock if we're still streaming
                        requestWakeLock();
                    }
                });
            } else {
                console.log('Wake Lock API not supported');
            }
        } catch (err) {
            console.error(`${err.name}, ${err.message}`);
        }
    }

    // Function to release wake lock
    async function releaseWakeLock() {
        if (wakeLock) {
            try {
                await wakeLock.release();
                wakeLock = null;
            } catch (err) {
                console.error(`${err.name}, ${err.message}`);
            }
        }
    }

    // Handle visibility change
    document.addEventListener('visibilitychange', async () => {
        if (streaming) {
            if (document.visibilityState === 'visible') {
                await requestWakeLock();
                if (!cameraStarted) {
                    await startCamera();
                }
            }
        }
    });

    // Automatically get the server URL from the current page
    const SERVER_URL = window.location.href.replace(/\/$/, '') + '/upload';
    
    // Network monitoring and adaptive quality
    function monitorNetworkPerformance(responseTime) {
      networkLatency = responseTime;
      
      // Adaptive quality based on network performance
      if (responseTime > 1000) {
        // High latency - reduce quality and fps
        adaptiveQuality = Math.max(0.3, adaptiveQuality - 0.1);
        targetFPS = Math.max(10, targetFPS - 5);  // More aggressive FPS reduction for 60fps
        compressionLevel = Math.max(0.3, compressionLevel - 0.1);
      } else if (responseTime < 200) {
        // Good connection - gradually increase quality
        adaptiveQuality = Math.min(0.8, adaptiveQuality + 0.05);
        targetFPS = Math.min(parseInt(maxFpsSelect.value), targetFPS + 2);  // Use selected max FPS
        compressionLevel = Math.min(0.8, compressionLevel + 0.05);
      }
      
      // Dynamic resolution adjustment for very poor connections
      if (responseTime > 2000 && !dynamicResolution) {
        dynamicResolution = true;
        currentWidth = Math.max(320, Math.floor(currentWidth * 0.7));
        currentHeight = Math.max(240, Math.floor(currentHeight * 0.7));
        console.log(`Reduced resolution to ${currentWidth}x${currentHeight} due to poor connection`);
      } else if (responseTime < 300 && dynamicResolution) {
        dynamicResolution = false;
        const [w, h] = resolutionSelect.value.split('x').map(Number);
        currentWidth = w;
        currentHeight = h;
        console.log(`Restored resolution to ${currentWidth}x${currentHeight}`);
      }
    }

    // Get available cameras
    async function getCameras() {
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const cameras = devices.filter(device => device.kind === 'videoinput');
        cameraSelect.innerHTML = cameras.map(camera => 
          `<option value="${camera.deviceId}">${camera.label || `Camera ${cameras.indexOf(camera) + 1}`}</option>`
        ).join('');
      } catch (err) {
        console.error('Error getting cameras:', err);
        status.textContent = 'Error loading cameras';
      }
    }

    // Request camera permission to get labels
    navigator.mediaDevices.getUserMedia({ video: true })
      .then(stream => {
        stream.getTracks().forEach(track => track.stop());
        getCameras();
      })
      .catch(() => {
        status.textContent = 'Camera permission denied';
      });

    async function checkWebPSupport() {
      // Test if WebP is supported by the browser
      return new Promise(resolve => {
        const img = new Image();
        img.onload = () => resolve(img.width === 1);
        img.onerror = () => resolve(false);
        img.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4TAYAAAAvAAAAAAfQ//73v/+BiOh/AAA=";
      });
    }

    async function startCamera() {
      try {
        const [w, h] = resolutionSelect.value.split('x').map(Number);
        currentWidth = w;
        currentHeight = h;
        
        // Try to get capabilities first
        let frameRateConstraint = { ideal: parseInt(maxFpsSelect.value) };
        
        // Check if selected camera supports high frame rates
        try {
          const devices = await navigator.mediaDevices.enumerateDevices();
          const selectedCamera = devices.find(device => device.deviceId === cameraSelect.value);
          if (selectedCamera) {
            const capabilities = selectedCamera.getCapabilities ? selectedCamera.getCapabilities() : null;
            if (capabilities && capabilities.frameRate) {
              const maxSupportedFPS = capabilities.frameRate.max || 30;
              const requestedFPS = parseInt(maxFpsSelect.value);
              if (requestedFPS > maxSupportedFPS) {
                frameRateConstraint = { ideal: maxSupportedFPS, max: maxSupportedFPS };
                console.log(`Camera supports max ${maxSupportedFPS}fps, adjusting from ${requestedFPS}fps`);
              }
            }
          }
        } catch (capError) {
          console.log('Could not get camera capabilities, using default constraints');
        }
        
        const stream = await navigator.mediaDevices.getUserMedia({
          video: {
            width: { ideal: w },
            height: { ideal: h },
            frameRate: frameRateConstraint,
            deviceId: { exact: cameraSelect.value }
          },
          audio: false
        });
        
        video.srcObject = stream;
        cameraStarted = true;
        
        // Check actual frame rate achieved
        const track = stream.getVideoTracks()[0];
        const settings = track.getSettings();
        const actualFPS = settings.frameRate || 'Unknown';
        status.textContent = `Camera started at ${w}x${h} @ ${actualFPS}fps. Ready to stream.`;
      } catch (err) {
        status.textContent = 'Camera or microphone access denied or not available.';
        console.error('Camera error:', err);
      }
    }

    async function sendFrame() {
      if (!streaming || !cameraStarted || uploading) return;
      if (video.videoWidth === 0 || video.videoHeight === 0) {
        status.textContent = 'Waiting for camera...';
        setTimeout(sendFrame, 100);
        return;
      }
      
      // Adaptive frame skipping based on target FPS - more precise for 60fps
      const frameInterval = 1000 / targetFPS;
      const timeSinceLastFrame = Date.now() - lastSuccessTime;
      if (timeSinceLastFrame < frameInterval - 2) {  // 2ms tolerance for 60fps precision
        const nextFrameDelay = Math.max(1, frameInterval - timeSinceLastFrame);
        setTimeout(sendFrame, nextFrameDelay);
        return;
      }
      
      // Skip frames if network is struggling - less aggressive for 60fps
      frameSkipCounter++;
      if (networkLatency > 500 && frameSkipCounter % 3 === 0) {  // Skip every 3rd frame instead of every 2nd
        setTimeout(sendFrame, 16);  // ~60fps timing
        return;
      }
      
      const canvas = document.createElement('canvas');
      canvas.width = currentWidth;
      canvas.height = currentHeight;
      const ctx = canvas.getContext('2d');
      
      // Enable image smoothing for better compression
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      
      // If the video is portrait (height > width), rotate to landscape
      if (video.videoHeight > video.videoWidth) {
        ctx.save();
        ctx.translate(currentWidth / 2, currentHeight / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.drawImage(video, -currentHeight / 2, -currentWidth / 2, currentHeight, currentWidth);
        ctx.restore();
      } else {
        ctx.drawImage(video, 0, 0, currentWidth, currentHeight);
      }
      
      uploading = true;
      const startTime = Date.now();
      
      let blob;
      if (useWebP) {
        blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/webp', adaptiveQuality));
      } else {
        blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', compressionLevel));
      }
      
      if (!blob) {
        status.textContent = 'No frame to send.';
        uploading = false;
        setTimeout(sendFrame, 100);
        return;
      }
      
      try {
        const response = await fetch(SERVER_URL, {
          method: 'POST',
          headers: { 
            'Content-Type': 'application/octet-stream',
            'Connection': 'keep-alive'
          },
          body: blob,
          signal: AbortSignal.timeout(5000) // 5 second timeout
        });
        
        const responseTime = Date.now() - startTime;
        monitorNetworkPerformance(responseTime);
        lastSuccessTime = Date.now();
        frameDropCount = Math.max(0, frameDropCount - 1); // Reduce drop count on success
        
        status.textContent = `Streaming... (${Math.round(blob.size/1024)}KB, ${responseTime}ms, Q:${Math.round(adaptiveQuality*100)}%)`;
        
        // Performance info for high FPS streaming
        const efficiency = (currentFPS / parseInt(maxFpsSelect.value) * 100).toFixed(1);
        performanceInfo.textContent = `Efficiency: ${efficiency}% | Drops: ${frameDropCount} | Adaptive FPS: ${targetFPS}`;
        
        // FPS calculation
        frameCount++;
        const now = performance.now();
        if (!lastFrameTime) lastFrameTime = now;
        if (now - lastFrameTime >= 1000) {
          currentFPS = frameCount;
          fpsDisplay.textContent = `FPS: ${frameCount} | Target: ${targetFPS} | Latency: ${networkLatency}ms`;
          frameCount = 0;
          lastFrameTime = now;
        }
      } catch (e) {
        frameDropCount++;
        const responseTime = Date.now() - startTime;
        
        if (e.name === 'TimeoutError') {
          status.textContent = 'Connection timeout - reducing quality';
          monitorNetworkPerformance(5000); // Simulate high latency
        } else {
          status.textContent = `Failed to send frame (${frameDropCount} drops)`;
          // Exponential backoff on repeated failures
          const backoffDelay = Math.min(1000, 100 * Math.pow(2, Math.min(frameDropCount, 5)));
          uploading = false;
          if (streaming) {
            setTimeout(sendFrame, backoffDelay);
          }
          return;
        }
      }
      
      uploading = false;
      if (streaming) {
        // Dynamic delay based on performance - optimized for 60fps
        const baseDelay = 1000 / targetFPS;
        const processingTime = Date.now() - startTime;
        const nextFrameDelay = Math.max(1, baseDelay - processingTime);  // Account for processing time
        setTimeout(sendFrame, nextFrameDelay);
      }
    }

    qualitySelect.onchange = () => {
      const qualityValue = qualitySelect.value;
      if (qualityValue === 'auto') {
        // Keep adaptive quality enabled
      } else {
        const qualityMap = { 'high': 0.8, 'medium': 0.7, 'low': 0.5 };
        adaptiveQuality = qualityMap[qualityValue] || 0.7;
        compressionLevel = adaptiveQuality;
      }
    };

    maxFpsSelect.onchange = () => {
      const selectedFPS = parseInt(maxFpsSelect.value);
      targetFPS = selectedFPS;
      
      // Reset adaptive quality when changing FPS target
      if (selectedFPS === 60) {
        adaptiveQuality = 0.6;  // Start with slightly lower quality for 60fps
        compressionLevel = 0.6;
      } else {
        adaptiveQuality = 0.7;  // Default quality for lower fps
        compressionLevel = 0.7;
      }
      
      console.log(`Target FPS changed to: ${selectedFPS}`);
    };

    resolutionSelect.onchange = async () => {
      if (streaming) {
        streaming = false;
        startBtn.textContent = 'Start Streaming';
        status.textContent = 'Restarting camera...';
        await startCamera();
        streaming = true;
        startBtn.textContent = 'Stop Streaming';
        sendFrame();
      }
    };

    cameraSelect.onchange = async () => {
      if (streaming) {
        streaming = false;
        startBtn.textContent = 'Start Streaming';
        status.textContent = 'Restarting camera...';
        await startCamera();
        streaming = true;
        startBtn.textContent = 'Stop Streaming';
        sendFrame();
      }
    };    startBtn.onclick = async () => {
      if (!streaming) {
        if (!cameraStarted) {
          status.textContent = 'Requesting camera access...';
          await startCamera();
          if (!cameraStarted) return;
        }
        streaming = true;
        startBtn.textContent = 'Stop Streaming';
        
        // Request wake lock when streaming starts
        await requestWakeLock();
        
        // Set up auto-reconnect monitoring
        streamReconnectAttempts = 0;
        if (reconnectTimer) clearInterval(reconnectTimer);
        reconnectTimer = setInterval(async () => {
          if (streaming && !cameraStarted && streamReconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
            streamReconnectAttempts++;
            status.textContent = `Attempting to reconnect... (${streamReconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`;
            await startCamera();
            if (cameraStarted) {
              streamReconnectAttempts = 0;
              status.textContent = 'Camera reconnected successfully.';
            }
          } else if (streamReconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
            status.textContent = 'Max reconnection attempts reached. Please restart streaming.';
            streaming = false;
            startBtn.textContent = 'Start Streaming';
            clearInterval(reconnectTimer);
          }
        }, 5000);  // Check every 5 seconds

        sendFrame();
        if (!fpsTimer) {
          fpsTimer = setInterval(() => {
            fpsDisplay.textContent = `FPS: ${frameCount}`;
            frameCount = 0;
          }, 1000);
        }      } else {
        streaming = false;
        startBtn.textContent = 'Start Streaming';
        status.textContent = 'Stopped.';
        
        // Release wake lock when stopping
        await releaseWakeLock();
        
        // Clear reconnect timer
        if (reconnectTimer) {
            clearInterval(reconnectTimer);
            reconnectTimer = null;
        }
        
        if (fpsTimer) {
          clearInterval(fpsTimer);
          fpsTimer = null;
        }
        fpsDisplay.textContent = '';
      }
    };

    // On load, check for WebP support
    (async () => {
      useWebP = await checkWebPSupport();
    })();
  </script>
</body>
</html>
