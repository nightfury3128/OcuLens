<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>iPhone Webcam Streamer</title>
  <style>
    body { text-align: center; font-family: sans-serif; }
    video { width: 90vw; max-width: 480px; border: 2px solid #333; border-radius: 8px; }
    button { margin-top: 16px; padding: 10px 20px; font-size: 1.2em; }
    select { margin: 5px; padding: 5px; }
  </style>
</head>
<body>
  <h2>iPhone Webcam Streamer</h2>
  <video id="video" autoplay playsinline></video><br>
  <label for="camera">Camera:</label>
  <select id="camera">
    <option value="">Loading cameras...</option>
  </select>
  <br>
  <label for="resolution">Resolution:</label>
  <select id="resolution">
    <option value="3840x2160">3840x2160 (4K)</option>
    <option value="1280x720">1280x720</option>
    <option value="960x540">960x540</option>
    <option value="640x360">640x360</option>
  </select>
  <button id="start">Start Streaming</button>
  <p id="status"></p>
  <p id="fpsDisplay"></p>
  <script>
    const video = document.getElementById('video');
    const startBtn = document.getElementById('start');
    const status = document.getElementById('status');
    const resolutionSelect = document.getElementById('resolution');
    const cameraSelect = document.getElementById('camera');
    const fpsDisplay = document.getElementById('fpsDisplay');
    let streaming = false;
    let cameraStarted = false;
    let uploading = false;
    let lastFrameTime = 0;
    let frameCount = 0;
    let fpsTimer = null;    let currentWidth = 1280;
    let currentHeight = 720;
    let useWebP = false;
    let wakeLock = null;
    let reconnectTimer = null;
    let streamReconnectAttempts = 0;
    const MAX_RECONNECT_ATTEMPTS = 5;

    // Function to keep screen awake
    async function requestWakeLock() {
        try {
            if ('wakeLock' in navigator) {
                wakeLock = await navigator.wakeLock.request('screen');
                console.log('Wake Lock is active');
                wakeLock.addEventListener('release', () => {
                    console.log('Wake Lock was released');
                    if (streaming) {
                        // Try to reacquire wake lock if we're still streaming
                        requestWakeLock();
                    }
                });
            } else {
                console.log('Wake Lock API not supported');
            }
        } catch (err) {
            console.error(`${err.name}, ${err.message}`);
        }
    }

    // Function to release wake lock
    async function releaseWakeLock() {
        if (wakeLock) {
            try {
                await wakeLock.release();
                wakeLock = null;
            } catch (err) {
                console.error(`${err.name}, ${err.message}`);
            }
        }
    }

    // Handle visibility change
    document.addEventListener('visibilitychange', async () => {
        if (streaming) {
            if (document.visibilityState === 'visible') {
                await requestWakeLock();
                if (!cameraStarted) {
                    await startCamera();
                }
            }
        }
    });

    // Automatically get the server URL from the current page
    const SERVER_URL = window.location.href.replace(/\/$/, '') + '/upload';

    // Get available cameras
    async function getCameras() {
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const cameras = devices.filter(device => device.kind === 'videoinput');
        cameraSelect.innerHTML = cameras.map(camera => 
          `<option value="${camera.deviceId}">${camera.label || `Camera ${cameras.indexOf(camera) + 1}`}</option>`
        ).join('');
      } catch (err) {
        console.error('Error getting cameras:', err);
        status.textContent = 'Error loading cameras';
      }
    }

    // Request camera permission to get labels
    navigator.mediaDevices.getUserMedia({ video: true })
      .then(stream => {
        stream.getTracks().forEach(track => track.stop());
        getCameras();
      })
      .catch(() => {
        status.textContent = 'Camera permission denied';
      });

    async function checkWebPSupport() {
      // Test if WebP is supported by the browser
      return new Promise(resolve => {
        const img = new Image();
        img.onload = () => resolve(img.width === 1);
        img.onerror = () => resolve(false);
        img.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4TAYAAAAvAAAAAAfQ//73v/+BiOh/AAA=";
      });
    }

    async function startCamera() {
      try {
        const [w, h] = resolutionSelect.value.split('x').map(Number);
        currentWidth = w;
        currentHeight = h;        const stream = await navigator.mediaDevices.getUserMedia({
          video: {
            width: { ideal: w },
            height: { ideal: h },
            deviceId: { exact: cameraSelect.value }
          },
          audio: false
        });
        video.srcObject = stream;
        cameraStarted = true;
        status.textContent = `Camera started at ${w}x${h}. Ready to stream.`;
      } catch (err) {
        status.textContent = 'Camera or microphone access denied or not available.';
      }
    }

    async function sendFrame() {
      if (!streaming || !cameraStarted || uploading) return;
      if (video.videoWidth === 0 || video.videoHeight === 0) {
        status.textContent = 'Waiting for camera...';
        setTimeout(sendFrame, 100);
        return;
      }
      const canvas = document.createElement('canvas');
      canvas.width = currentWidth;
      canvas.height = currentHeight;
      const ctx = canvas.getContext('2d');
      // If the video is portrait (height > width), rotate to landscape
      if (video.videoHeight > video.videoWidth) {
        ctx.save();
        ctx.translate(currentWidth / 2, currentHeight / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.drawImage(video, -currentHeight / 2, -currentWidth / 2, currentHeight, currentWidth);
        ctx.restore();
      } else {
        ctx.drawImage(video, 0, 0, currentWidth, currentHeight);
      }
      uploading = true;
      let blob;
      if (useWebP) {
        blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/webp', 0.5));
      } else {
        blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 0.3));
      }
      if (!blob) {
        status.textContent = 'No frame to send.';
        uploading = false;
        setTimeout(sendFrame, 100);
        return;
      }
      try {
        await fetch(SERVER_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/octet-stream' },
          body: blob
        });
        status.textContent = 'Streaming...';
        // FPS calculation
        frameCount++;
        const now = performance.now();
        if (!lastFrameTime) lastFrameTime = now;
        if (now - lastFrameTime >= 1000) {
          fpsDisplay.textContent = `FPS: ${frameCount}`;
          frameCount = 0;
          lastFrameTime = now;
        }
      } catch (e) {
        status.textContent = 'Failed to send frame.';
      }
      uploading = false;
      if (streaming) sendFrame();
    }

    resolutionSelect.onchange = async () => {
      if (streaming) {
        streaming = false;
        startBtn.textContent = 'Start Streaming';
        status.textContent = 'Restarting camera...';
        await startCamera();
        streaming = true;
        startBtn.textContent = 'Stop Streaming';
        sendFrame();
      }
    };

    cameraSelect.onchange = async () => {
      if (streaming) {
        streaming = false;
        startBtn.textContent = 'Start Streaming';
        status.textContent = 'Restarting camera...';
        await startCamera();
        streaming = true;
        startBtn.textContent = 'Stop Streaming';
        sendFrame();
      }
    };    startBtn.onclick = async () => {
      if (!streaming) {
        if (!cameraStarted) {
          status.textContent = 'Requesting camera access...';
          await startCamera();
          if (!cameraStarted) return;
        }
        streaming = true;
        startBtn.textContent = 'Stop Streaming';
        
        // Request wake lock when streaming starts
        await requestWakeLock();
        
        // Set up auto-reconnect monitoring
        streamReconnectAttempts = 0;
        if (reconnectTimer) clearInterval(reconnectTimer);
        reconnectTimer = setInterval(async () => {
          if (streaming && !cameraStarted && streamReconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
            streamReconnectAttempts++;
            status.textContent = `Attempting to reconnect... (${streamReconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`;
            await startCamera();
            if (cameraStarted) {
              streamReconnectAttempts = 0;
              status.textContent = 'Camera reconnected successfully.';
            }
          } else if (streamReconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
            status.textContent = 'Max reconnection attempts reached. Please restart streaming.';
            streaming = false;
            startBtn.textContent = 'Start Streaming';
            clearInterval(reconnectTimer);
          }
        }, 5000);  // Check every 5 seconds

        sendFrame();
        if (!fpsTimer) {
          fpsTimer = setInterval(() => {
            fpsDisplay.textContent = `FPS: ${frameCount}`;
            frameCount = 0;
          }, 1000);
        }      } else {
        streaming = false;
        startBtn.textContent = 'Start Streaming';
        status.textContent = 'Stopped.';
        
        // Release wake lock when stopping
        await releaseWakeLock();
        
        // Clear reconnect timer
        if (reconnectTimer) {
            clearInterval(reconnectTimer);
            reconnectTimer = null;
        }
        
        if (fpsTimer) {
          clearInterval(fpsTimer);
          fpsTimer = null;
        }
        fpsDisplay.textContent = '';
      }
    };

    // On load, check for WebP support
    (async () => {
      useWebP = await checkWebPSupport();
    })();
  </script>
</body>
</html>
